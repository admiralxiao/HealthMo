# 睡眠分期算法（C++）保护方案（iOS 端侧）

更新时间：2026-01-30  
目标：让攻击者“很难拿走算法/权重/关键规则”，并尽可能降低被 hook 的收益。

---

## 1. 交付形态建议（强制）
### 1.1 使用 XCFramework（静态或动态）
- 产物：`SleepStage.xcframework`
- iOS App 只暴露极少的 Swift/ObjC API（门面层）
- 所有核心实现留在 C++ 内部，减少 Swift 可读性

建议：
- 优先 **静态库**（减少动态注入面，但仍可被静态分析）
- 公开 API 控制在 5–10 个函数以内

---

## 2. 构建级防逆向（必须）
### 2.1 符号与调试信息
- `Strip Symbols`：Release 开启
- `DWARF with dSYM`：仅保留 dSYM 上报崩溃，不把符号留在包内
- C++：移除可读函数名/字符串常量（避免在二进制中出现“stage/rem”等关键字）

### 2.2 编译与链接
- LTO（Link Time Optimization）可提高分析难度（同时减小体积）
- 关闭不必要 RTTI/异常（如可行）减少可读元信息
- 将关键常量集中在“运行时生成”（避免明文常量）

---

## 3. 运行时防篡改与反 hook（建议，别过度）
> 注意：过强的反调试可能影响正常用户与审核体验。MVP 建议“风险评分 + 降级”。

### 3.1 环境风险检测（低侵入）
- 是否处于调试态（debugger attached）
- 是否存在明显注入痕迹（典型动态库列表异常）
- Jailbreak 迹象（只作为 risk signal，不硬拦）

处置策略：
- risk 低：正常
- risk 中：隐藏部分高价值 explain、降低刷新频率
- risk 高：服务端要求重新认证（App Attest）或限制 premium 特性

### 3.2 输出完整性校验（防 hook 改返回值）
- 对算法输出（stages/score）做 **轻量签名/校验**：
  - 例如将输入摘要 + params_version + 输出摘要做 HMAC（key 来自 Secure Enclave/Keychain）
- 目的是让“简单 hook 返回 100 分”更容易被检测到（尤其在与服务端数据对比时）

---

## 4. 机密资产保护（如果算法有权重/表）
- 权重/查表数据不应明文打包：
  - App 内置 **加密 blob**（AES-GCM）
  - 解密 key：来自设备侧（Keychain + per-install secret）与服务端结合（更强）
- 分段加载：只在需要时解密到内存，使用后尽快释放

---

## 5. “端侧必须算”与“可以云端算”的分层建议
- 端侧必须：基础分期、基础得分（体验/隐私）
- 云端增强（Premium）：解释、趋势、个性化策略、异常检测
> 这样即使端侧算法被拿走，核心商业价值仍在服务端闭环。

---

## 6. 可落地清单（MVP 必做）
- [ ] 以 XCFramework 形式交付 C++ 核心
- [ ] Release：符号剥离 + 最小公开 API
- [ ] 去除可读字符串（stage 名称、规则描述）
- [ ] params_version 进入算法输入（防止被替换参数）
- [ ] 输出加入 checksum（用于一致性与异常检测）

---
